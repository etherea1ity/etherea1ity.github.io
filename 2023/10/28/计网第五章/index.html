<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计网第三章 | Jerryの魔法小屋</title><meta name="author" content="Jerry Jiang"><meta name="copyright" content="Jerry Jiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第五章 运输层重要内容 运输层的作用 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠网络上实现可靠传输的原理 TCP的滑动窗口、流量控制、拥塞控制和连接管理  核心知识点运输层协议概述进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。  运输层有一个很重要的功能，复用和分用。  只有位于">
<meta property="og:type" content="article">
<meta property="og:title" content="计网第三章">
<meta property="og:url" content="http://example.com/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0/index.html">
<meta property="og:site_name" content="Jerryの魔法小屋">
<meta property="og:description" content="第五章 运输层重要内容 运输层的作用 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠网络上实现可靠传输的原理 TCP的滑动窗口、流量控制、拥塞控制和连接管理  核心知识点运输层协议概述进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。  运输层有一个很重要的功能，复用和分用。  只有位于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg">
<meta property="article:published_time" content="2023-10-28T06:44:55.000Z">
<meta property="article:modified_time" content="2023-11-28T12:53:16.617Z">
<meta property="article:author" content="Jerry Jiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计网第三章',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 20:53:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Jerryの魔法小屋"><span class="site-name">Jerryの魔法小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计网第三章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-28T06:44:55.000Z" title="发表于 2023-10-28 14:44:55">2023-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T12:53:16.617Z" title="更新于 2023-11-28 20:53:16">2023-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计网第三章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><h2 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h2><ul>
<li><strong>运输层的作用</strong></li>
<li><strong>端口和套接字</strong>的意义</li>
<li><strong>无连接的UDP</strong>的特点</li>
<li><strong>面向连接的TCP</strong>的特点</li>
<li>在不可靠网络上实现<strong>可靠传输</strong>的原理</li>
<li>TCP的<strong>滑动窗口、流量控制、拥塞控制和连接管理</strong></li>
</ul>
<h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><h4 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h4><ol>
<li><p>从通信和信息处理的角度看，运输层向它上面的<strong>应用层</strong>提供通信服务，它属于<strong>面向通信部分的最高层，</strong>同时也是<strong>用户功能中的最低层。</strong></p>
</li>
<li><p>运输层有一个很重要的功能，<strong>复用</strong>和<strong>分用</strong>。</p>
<ol>
<li><p>只有位于网络边缘部分的<strong>主机的协议栈</strong>才有运输层。（<strong>主机-五层</strong>）</p>
</li>
<li><p>而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 （<strong>路由器-三层</strong>）</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/yunshucengtu.png" alt="运输层"></p>
<ol>
<li><p>与网络层</p>
<ol>
<li><p>网络层的作用是为<strong>互联网上的主机</strong>之间提供逻辑通信。</p>
</li>
<li><p>运输层的作用是为<strong>互联网上的主机上的应用进程</strong>之间提供端到端的逻辑通信。</p>
</li>
<li><p>网络层的差错检测仅检测IP数据报首部的内容是否出错（<strong>通过首部检验和</strong>），而运输层可以提供<strong>可靠的信道（TCP）或不可靠的信道（UDP）</strong>。</p>
</li>
</ol>
</li>
<li><p>为<strong>互联网上的主机上的应用进程</strong>之间提供<strong>端到端</strong>的<strong>逻辑通信</strong>。</p>
</li>
<li><p><strong>屏蔽作用</strong>，运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
</li>
</ol>
<h4 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h4><ol>
<li><strong>面向连接的TCP协议</strong>，<strong>尽管下面的网络是不可靠的（最大努力服务）</strong>，但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li><p><strong>无连接的UDP协议</strong>，仍然是一条<strong>不可靠信道</strong>。</p>
</li>
<li><p><strong>用户数据报协议 UDP</strong> User Datagram Protocol</p>
<ol>
<li><p><strong>无连接，不可靠</strong>，协议数据单元为<strong>用户数据报</strong>。<strong>可靠性差，但传输效率好，实时性好</strong>。适用于只对数据传输的实时性要求较高，但对传输质量要求低的场景，如<strong>在线语音、视频聊天</strong>等。</p>
</li>
<li><p>在传送数据之前<strong>不需要先建立连接。</strong>发送完数据后，不需要接到对方的确认。有些情况下最有效。</p>
</li>
</ol>
</li>
<li><p>传输控制协议TCP（Transition Control Protocol）：</p>
<ol>
<li><p><strong>面向连接，可靠</strong>，协议数据单元为<strong>TCP报文段</strong>。<strong>传输效率低，实时性差，但可靠性高</strong>，适用于对数据传输的质量有较高要求，但对实时性要求不高的场景，如<strong>传输文件</strong>（HTTP、HTTPS、FTP）、<strong>发送邮件</strong>（SMTP）、<strong>远程登录</strong>（SSH、TELNET）等协议。</p>
</li>
<li><p><strong>需要先建立连接</strong>。对方收到TCP报文段后需<strong>要给出确认</strong>。</p>
</li>
<li><p>TCP 不提供<strong>广播或多播</strong>服务。</p>
</li>
<li><p>由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地<strong>增加了许多的开销</strong>， 如<strong>确认、流量控制、计时器以及连接管理</strong>等 。这不仅<strong>使协议数据单元的首部增大很多</strong>，还要<strong>占用许多的处理机资源</strong>。（<strong>用户数据报的首部仅为8个字节，而TCP报文段的首部为20到60个字节</strong>）</p>
</li>
<li><p>常用TCP的应用和应用层协议：<strong>SMTP、TELNET、HTTP、FTP等。</strong></p>
</li>
</ol>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">对比项</th>
<th style="text-align:left">TCP</th>
<th style="text-align:left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">可靠性</td>
<td style="text-align:left"><strong>可靠</strong></td>
<td style="text-align:left"><strong>不可靠</strong></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">连接性</td>
<td style="text-align:left"><strong>面向连接</strong></td>
<td style="text-align:left"><strong>无连接</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">报文（Message）</td>
<td style="text-align:left">面向<strong>字节流</strong>（Byte Stream，可以对过长报文分片）</td>
<td style="text-align:left">面向<strong>报文</strong>（Message）（保留报文的边界，不可分）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">效率</td>
<td style="text-align:left">传输效率<strong>低</strong></td>
<td style="text-align:left">传输效率<strong>高</strong></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">双工性</td>
<td style="text-align:left"><strong>全双工，但不提供广播或多播服务</strong></td>
<td style="text-align:left"><strong>一对一、一对多、多对一，多对多</strong></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">流量控制</td>
<td style="text-align:left"><strong>有（滑动窗口）</strong></td>
<td style="text-align:left"><strong>无</strong></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">拥塞控制</td>
<td style="text-align:left"><strong>有（慢开始、拥塞避免、快重传、快恢复）</strong></td>
<td style="text-align:left"><strong>无</strong></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">传输速度</td>
<td style="text-align:left"><strong>慢</strong></td>
<td style="text-align:left"><strong>快</strong></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">应用场合</td>
<td style="text-align:left"><strong>（1）对效率要求相对低，但对准确性要求相对高的场景（2）有连接的场景</strong></td>
<td style="text-align:left"><strong>对效率要求相对高，但对准确性要求相对低的场景</strong>。或者需要<strong>广播</strong>的场景，如DHCP和SNMP。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">应用实例</td>
<td style="text-align:left">（1）<strong>文件传输</strong>（FTP，HTTP 对数据的准确性要求高，速度可以相对慢）；（2）<strong>发送或接收邮件</strong>（SMTP、POP3，IMAP 对数据准确性要求高，非紧急应用）（3）<strong>远程登录</strong>（SSH，TELNET 对数据准确性有一定要求，有连接概念）等等</td>
<td style="text-align:left">（1）<strong>即时通信</strong>（QQ聊天，对数据准确性和丢包要求比较低，但速度必须快）；（2）<strong>在线视频</strong>（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的）（3）<strong>网络语音电话</strong>（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等</td>
</tr>
</tbody>
</table>
</div>
<h4 id="运输层的端口（软件端口）：解决分用问题。"><a href="#运输层的端口（软件端口）：解决分用问题。" class="headerlink" title="运输层的端口（软件端口）：解决分用问题。"></a>运输层的端口（<strong>软件端口</strong>）：解决分用问题。</h4><ol>
<li><p><strong>复用</strong>，应用层所有的应用进程都可以通过传输层再传到IP层。<strong>分用</strong>：运输层从IP层受到发送给各应用进程的数据后，必须分别交付指明的各应用进程。</p>
</li>
<li><p><strong>软件端口</strong>，<strong>在协议栈层间的抽象的协议端口，一般简称为端口port。</strong>与路由器或交换机的<strong>硬件端口</strong>不同。<strong>是应用层的各种协议进程</strong>与<strong>运输实体</strong>进行层间交互的地点。</p>
</li>
<li><p>TCP和UCP都有<strong>源端口</strong>和<strong>目的端口</strong>，TCP/IP应用层使用一个一个 <strong>16 位端口号（0到65535）</strong>。</p>
</li>
<li><p>端口只具有<strong>本地意义</strong>，即端口号只是为了标志本计算机应用层中的各进程。</p>
</li>
<li><p><strong>服务器端</strong>使用的端口号：</p>
<ol>
<li><strong>熟知端口</strong>，一般为0~1023，包括HTTP（80），HTTPS（443）等。</li>
<li><strong>登记端口号</strong>，数值为 <strong>1024~49151</strong>，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 <strong>IANA</strong> 登记，以防止重复。</li>
</ol>
</li>
<li><p><strong>客户端</strong>使用的端口号：</p>
<ol>
<li><p>又称为<strong>短暂端口号</strong>，数值为 <strong>49152~65535</strong>，留给客户进程选择暂时使用。</p>
</li>
<li><p>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的<strong>动态端口号</strong>。通信结束后，这个端口号被收回。</p>
</li>
</ol>
</li>
</ol>
<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><ol>
<li><p>UDP 只在 IP 的数据报服务之上增加了<strong>复用和分用</strong>和<strong>差错检测</strong>的功能</p>
</li>
<li><p>UDP 是<strong>无连接</strong>的，发送数据之前不需要建立连接，因此<strong>减少了开销和发送数据之前的时延</strong>。</p>
</li>
<li><p>UDP 使用<strong>尽最大努力</strong>交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p>
</li>
<li><p>UDP 是<strong>面向报文</strong>的。UDP 对应用层交下来的报文，在<strong>添加首部后就向下交付给IP层</strong>，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。UDP 一次交付一个<strong>完整的报文</strong>。由于UDP交付和接收的单位是一个报文，<strong>不会对报文进行分段</strong>。所以采用UDP发送的报文段<strong>需要长度适中</strong>。</p>
</li>
<li><p>UDP 没有<strong>拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。<strong>很适合多媒体通信（如IP电话、视频会议）的要求</strong>。 （但是，如果多个源主机上的进程使用UDP同时向网络发送实时视频流时，可能导致拥塞）</p>
</li>
<li><p>UDP 支持<strong>一对一、一对多、多对一和多对多</strong>的交互通信，而TCP不支持广播和多播。</p>
</li>
<li><p>UDP 的<strong>首部开销小</strong>，只有 <strong>8 个字节</strong>，比 TCP 的 20 个字节的首部要短。</p>
</li>
</ol>
<h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><ol>
<li><p>UDP首部有<strong>8个字节</strong>，首部中长度字段最小值为8，为仅有首部的UDP用户数据报。</p>
</li>
<li><p>UDP还需要<strong>12字节的伪首部</strong>，作用是用于<strong>计算检验和</strong>。伪首部不向上传送也不向下递交。UDP计算检验和的方法与IP数据报基本相同，唯一的区别在于<strong>UDP把首部（包含伪首部）和数据部分一起检验。</strong></p>
</li>
<li>如果UDP用户数据报的数据部分不是偶数个字节，则要填入一个全0的字节（但是不发送）。方法为发送方检测每个<strong>字</strong>的和（一个字两个字节），将其二进制反码写入检验和字段。在接收方把收到的UDP连同伪首部一起，按二进制反码求这些16位字的和，结果应该为<strong>全1</strong>。</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/UDPheader.png" alt="UDP"></p>
<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><h4 id="TCP最主要的特点"><a href="#TCP最主要的特点" class="headerlink" title="TCP最主要的特点"></a>TCP最主要的特点</h4><ol>
<li>TCP 是<strong>面向连接</strong>的运输层协议。发送前需要先建立连接。</li>
<li>每一条 TCP 连接只能有<strong>两个端点 endpoint</strong>，每一条 TCP 连接只能是<strong>点对点</strong>的（一对一）。</li>
<li>TCP 提供<strong>可靠交付</strong>的服务。</li>
<li>TCP 提供<strong>全双工通信</strong>。</li>
<li><strong>面向字节流</strong>。<strong>流stream</strong>指流入进程或从进程流出的字节序列。由于TCP将他们看作是<strong>无结构的字节流</strong>，并不知道其意义，因此接收方需要识别收到的字节流。</li>
<li><p>面向字节流的补充，<strong>TCP可以对报文的字节流进行分段形成报文段，而UDP不对报文进行分段</strong>。TCP不保证数据块的一致性，但<strong>保证数据块中的字节流的一致性。</strong></p>
</li>
<li><p>TCP 连接是一条<strong>虚连接（逻辑连接）</strong>而不是一条真正的物理连接。TCP报文先到IP层加上IP首部，再传送到数据链路层。再加上数据链路层的首部和尾部后才离开主机到物理链路。</p>
</li>
<li><p>TCP <strong>不关心</strong>应用进程一次发送多长的报文。</p>
</li>
<li><p>TCP 根据<strong>对方给出的窗口值（流量控制）和当前网络拥塞的程度（拥塞控制）</strong>来决定一个<strong>报文段</strong>应包含多少个字节（<strong>UDP 发送的报文长度是应用进程给出的</strong>）。</p>
</li>
<li><p>TCP 可把太长的数据块划分<strong>短一些</strong>再传送。 也可等待积累有<strong>足够多</strong>的字节后再构成报文段发送出去。</p>
</li>
</ol>
<h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><ol>
<li>TCP 把<strong>连接</strong>作为<strong>最基本的抽象</strong>。</li>
<li>每一条 TCP 连接<strong>有两个端点</strong>，为<strong>套接字（socket）或插口</strong>。</li>
<li><strong>端口号拼接到 （concatenated with）IP 地址</strong>即构成了套接字。如IP192.3.4.5，端口80，那么socket就是（192.3.4.5: 80）</li>
<li>$TCP 连接::=\{socket_1 , socket_2\}$。</li>
</ol>
<h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><p><strong>可靠传输</strong>的工作原理：确认机制+重传机制</p>
<p>理想传输条件的特点：</p>
<ol>
<li>传输信道<strong>不产生差错</strong>。</li>
<li>不管发送方以多快的速度发送数据，接收方总是<strong>来得及</strong>处理收到的数据。</li>
</ol>
<h4 id="停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）"><a href="#停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）" class="headerlink" title="停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）"></a>停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）</h4><ol>
<li><p>“停止等待”就是<strong>每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。如果在规定时间内没有收到确认，那么需要进行超时重传。</strong></p>
</li>
<li><p><strong>无差错</strong>：传输的TCP报文段没问题</p>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPwuchacuo.png" alt="无差错"></p>
<ol>
<li><strong>超时重传</strong>，每法送完一个分组时设置一个<strong>超时计时器</strong>。<ol>
<li>每发送完一个分组，要<strong>暂时保留已发送的分组的副本</strong>。</li>
<li>分组和确认分组要<strong>编号</strong>。</li>
<li>超时计时器设置的重传时间要比数据在分组传输的平均往返时间<strong>长一些</strong>。</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPchaoshichongchuan.png" alt="出现差错"></p>
<ol>
<li><strong>确认丢失</strong>，B发送给A的<strong>确认ACK</strong>丢失。若此时A重新传了一遍M1数据报。<ol>
<li>B<strong>丢弃这个重复的分组M1</strong>，不再向上层重复交付。</li>
<li><strong>向A发送确认ACK</strong>。</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPquerendiushi.png" alt="确认丢失"></p>
<ol>
<li><strong>确认迟到</strong>：B向A发送的确认报文ACK迟到了，<strong>A什么也不做</strong>。</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPquerenchidao.png" alt="确认迟到"></p>
<ol>
<li>通过上述的<strong>确认和重传机制</strong>，我们实现了在<strong>不可靠的传输网络上实现可靠的通信</strong>。</li>
<li><p><strong>自动重传请求ARQ（Automatic Repeat reQuest）</strong>。</p>
</li>
<li><p>停止等待协议的优点是<strong>简单</strong>，缺点是<strong>信道利用率太低</strong>。原因是需要耗费大量的时间在每一个分组发送后的等待确认上，解决的办法是<strong>滑动窗口协议</strong>，通过<strong>连续窗口发送和累积确认</strong>，提高信道利用率。</p>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/xindaoliyonglvdi.png" alt="停止等待协议"></p>
<h3 id="TCP报文段的首部格式："><a href="#TCP报文段的首部格式：" class="headerlink" title="TCP报文段的首部格式："></a>TCP报文段的<strong>首部格式</strong>：</h3><ol>
<li>TCP 报文段首部的<strong>前 20 个字节</strong>是固定的，后面有 <strong>4n 字节</strong>是根据需要而增加的选项 n是整数。因此 TCP 首部的<strong>最小长度是 20 字节。最长为60字节。</strong>（与IP数据报的首部类似）</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPheader.png" alt=""></p>
<ol>
<li><p><strong>源端口和目的端口字段</strong>——各占 <strong>2 字节</strong>。端口是运输层与应用层的服务接口。运输层的<strong>复用和分用</strong>功能都要通过端口才能实现。</p>
</li>
<li><p><strong>序号字段</strong>——占 <strong>4 字节</strong>。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。</p>
</li>
<li><p><strong>确认号字段ack</strong>——占 <strong>4 字节</strong>，是期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
</li>
<li><p><strong>数据偏移（即首部长度）</strong>——占 <strong>4 位</strong>，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<strong>“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</strong>。</p>
</li>
<li><p><strong>保留字段</strong>——<strong>占 6 位</strong>，保留为今后使用，但目前应置为 0。</p>
</li>
<li><p><strong>紧急 URG</strong> —— 当 <strong>URG=1</strong> 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应<strong>尽快传送</strong>相当于高优先级的数据相当于高优先级的数据。 例如，向远程主机发送Control+c的中断命令。</p>
</li>
<li><p><strong>确认 ACK（注意大小写，大写为确认位，小写为确认号）</strong> —— 只有当 <strong>ACK=1</strong> 时确认号字段才有效。当 ACK=0 时，确认号无效。 例如，<strong>停止等待协议的确认分组。</strong></p>
</li>
<li><p><strong>推送 PSH PuSH —— 接收 TCP 收到 </strong>PSH = 1<strong> 的报文段，就</strong>尽快地交付**接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p>
</li>
<li><p><strong>复位 RST ReSeT —— 当 </strong>RST=1<strong> 时，表明 TCP 连接中出现</strong>严重差错<strong>（如由于主机崩溃或其他原因），必须</strong>释放连接<strong>，然后再</strong>重新建立运输连接**。</p>
</li>
<li><p><strong>同步 SYN</strong> —— <strong>同步 SYN = 1 表示这是一个连接请求或连接接受报文</strong>。</p>
</li>
<li><p><strong>终止 FIN FINish</strong> —— 用来<strong>释放一个连接</strong>。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</p>
</li>
<li><p><strong>窗口字段</strong> —— 占 <strong>2 字节</strong>，用来让对方设置发送窗口的依据，单位为<strong>字节</strong>。指的是发送本报文段的一方的接收窗口。（<strong>发送方的发送窗口应小于等于拥塞窗口cnwd和接收方的接收窗口中的最小值</strong>）</p>
</li>
<li><p><strong>检验和</strong> —— 占 <strong>2 字节</strong>。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 <strong>12 字节的伪首部</strong>。（和UDP基本类似，但伪首部略有区别）</p>
</li>
<li><p><strong>紧急指针字段</strong> —— <strong>占 16 位</strong>，指出在本报文段中<strong>紧急数据共有多少个字节</strong>（紧急数据放在本报文段数据的最前面）。<strong>和URG字段配合使用</strong>。</p>
</li>
<li><p>选项字段—— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。也就是<strong>TCP报文段数据字段的最大长度</strong>。</p>
</li>
<li><p>MSS 与接收窗口值没有关系。若选择较小的 MSS 长度，网络的利用率就降低。MSS 应尽可能大些，最佳的 MSS 是很难确定的.</p>
</li>
<li><p>其他选项</p>
<ol>
<li><p><strong>窗口扩大选项</strong> ——<strong>占 3 字节</strong>，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数从16位增大到S+16，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</p>
</li>
<li><p><strong>时间戳选项</strong>——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</p>
</li>
<li><p><strong>选择确认选项</strong>。</p>
</li>
<li><p><strong>填充字段</strong> —— 这是为了使整个首部长度<strong>是 4 字节的整数倍</strong>。</p>
</li>
</ol>
</li>
</ol>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><h4 id="连续的ARQ协议"><a href="#连续的ARQ协议" class="headerlink" title="连续的ARQ协议"></a>连续的ARQ协议</h4><ol>
<li><p>发送方维持的发送窗口，它的意义是：<strong>位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认</strong>。这样，信道利用率就提高了。（基础的ARQ协议，即停止等待协议，需要每发送一个分组就等待一次确认，效率很低）</p>
</li>
<li><p><strong>滑动窗口</strong>：连续 ARQ 协议规定，发送方每<strong>收到一个确认</strong>，就把<strong>发送窗口向前滑动一个分组</strong>的位置。</p>
</li>
<li><p><strong>累积确认</strong>：接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是对<strong>按序到达的最后一个分组</strong>发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。（规定时间内，没有继续收到按序到达的分组，就依据当前按序到达的最后一个分组发送确认）</p>
</li>
<li><p>优点：<strong>容易实现，即使确认丢失也不必重传。</strong></p>
</li>
<li><p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。当按序到达的分组中间某处发生分组丢失时，需要进行<strong>Go-back-N（回退 N）</strong>，表示需要再退回来重传已发送过的 N 个分组。</p>
</li>
</ol>
<h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><ol>
<li><p>选择重传</p>
<ol>
<li><p>优点：<strong>提高信道效率。</strong>（不必重传已发送成功的分组）</p>
</li>
<li><p>缺点：接收方需要<strong>更大缓存</strong>。（需要将丢失分组后面序号的分组暂时保存在接收方的缓存区，等待重传的分组到达，再一起接收）</p>
</li>
</ol>
</li>
<li><p>回退N步</p>
<ol>
<li><p>优点：<strong>接收方缓存区小</strong>。</p>
</li>
<li><p>缺点：<strong>信道效率低</strong>，需要重传正确的分组。</p>
</li>
</ol>
</li>
<li><p>具体实现：TCP 的滑动窗口是<strong>以字节为单位（TCP面向字节流）</strong>的。现假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节（<strong>流量控制</strong>），而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。根据这两个数据，A 就构造出自己的发送窗口(实际情况下,还需要考虑<strong>拥塞窗口</strong>):</p>
</li>
<li><p>TCP 连接的每一端都必须设有两个窗口——<strong>一个发送窗口和一个接收窗口</strong>。总共有4个窗口，窗口的大小根据拥塞控制和流量控制动态改变。</p>
<ol>
<li>发送窗口表示：<strong>在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。</strong></li>
<li>接收窗口表示：<strong>接收方允许接收的字节序号</strong>。</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/Asend11bytes.png" alt=""></p>
<ol>
<li>如37，38，40未按序到达，只能先存在接收窗口中，等A收到B的确认后，就可以把发送窗口向前滑动3个序号，但p2指针不变。</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/Areceiveack.png" alt=""></p>
<ol>
<li><p>TCP连接的每一端都拥有<strong>发送缓存和接收缓存。</strong></p>
</li>
<li><p>发送缓存用来暂时存放：</p>
<ol>
<li><p>发送应用程序传送给发送方 TCP <strong>准备发送</strong>的数据</p>
</li>
<li><p>TCP 已发送出但<strong>尚未收到确认的</strong>数据。</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPfasonghuancun.png" alt="发送缓存"></p>
<ol>
<li><p>接收缓存用来暂时存放：</p>
<ol>
<li><p>按序到达的、但尚未<strong>被接收应用程序读取</strong>的数据；</p>
</li>
<li><p><strong>不按序到达</strong>的数据。（<strong>选择重传</strong>）</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPjieshouhuancun.png" alt="接收缓存"></p>
<ol>
<li><p>A 的发送窗口并不总是和 B 的接收窗口<strong>一样大</strong>（因为有一定的<strong>时间滞后</strong>）。</p>
</li>
<li><p>TCP 标准没有规定对不按序到达的数据应如何处理。通常是<strong>先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</strong>。</p>
</li>
<li><p>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。</p>
</li>
<li><p><strong>捎带确认</strong>:接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带.但要注意:第一，接收方不应<strong>过分推迟</strong>发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。第二，捎带确认实际上<strong>并不经常发生</strong>，因为大多数应用程序很少同时在两个方向上发送数据.</p>
</li>
</ol>
<h4 id="超时重传时间RTO"><a href="#超时重传时间RTO" class="headerlink" title="超时重传时间RTO"></a>超时重传时间RTO</h4><ol>
<li><p>超时重传时间是指：<strong>TCP发送方在超时重传时间内没有收到接收方发送的确认就要重传已发送的TCP报文段。</strong></p>
</li>
<li><p>超时重传时间设置的困难：</p>
<ol>
<li><p>如果把超时重传时间设置得太短，就会引起很多报文段的<strong>不必要的重传</strong>，<strong>使网络负荷增大</strong>。</p>
</li>
<li><p>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，<strong>降低了传输效率。</strong></p>
</li>
</ol>
</li>
<li><p><strong>往返时间RTT</strong>：记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</p>
</li>
<li><p><strong>加权平均往返时间 $RTT_S$</strong>（这又称为平滑的往返时间，指数加权平均，就像机器学习中的动量梯度下降算法）</p>
<ol>
<li><p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。</p>
</li>
<li><p>以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS。RFC 2988 推荐的<strong>α值为 1/8</strong>，即 0.125。<script type="math/tex">新的RTT_S=(1-a)*(旧的RTT_S)+a*(新的RTT样本)</script></p>
</li>
<li><p><strong>超时重传时间 RTO（Retransmission Time-Out）</strong>：应略大于上面得出的加权平均往返时间 $RTT_S$。RFC 2988 建议使用下式计算 RTO。<script type="math/tex">RTO=RTT_S+4*RTT_D</script></p>
</li>
<li><p>$RTT_D 是 RTT 的偏差的加权平均值$</p>
</li>
<li><p>第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。</p>
</li>
<li><p>在以后的测量中，则使用下式计算加权平均的$RTT_D$。RFC 2988 推荐的<strong>β值为 1/4</strong>，即 0.25。<script type="math/tex">新的RTT_D=(1-\beta)*|旧的RTT_S)+\beta*(RTT_S-新的RTT样本)|</script></p>
</li>
<li><p><strong>Karn 算法</strong>：在计算平均往返时间 RTT 时，只要<strong>报文段重传</strong>了，就不采用其往返时间样本。</p>
</li>
</ol>
</li>
<li><p><strong>选择确认SACK</strong>，收到的报文段无差错，只是缺少序号。</p>
</li>
</ol>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><h4 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h4><ol>
<li><p><strong>流量控制（flow control）</strong>：让发送方的发送速率<strong>不要太快</strong>，既要<strong>让接收方来得及接收，也不要使网络发生拥塞</strong>。（<strong>点对点，使用接收窗口控制</strong>）</p>
</li>
<li><p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。</p>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/flowcontrolTCP.png" alt=""></p>
<p>方法：不断<strong>减少接收窗口</strong>，即可降低数据发送速率。</p>
<p><strong>死锁</strong>：发送方因接收方的接收窗口为0，一直等待。此时，接收方有了一些窗口，但<strong>发送的非零窗口报文段丢失</strong>，导致双方互相等待死锁（<strong>发送方等待接收方的接收窗口大于0，而接收方等待发送方发送数据</strong>）。</p>
<p><strong>死锁的解决方案</strong>：TCP 为每一个连接设有一个<strong>持续计时器</strong>。只要 TCP 连接的一方收到对方的零窗口通知，就<strong>启动该持续计时器</strong>。若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（仅携带 <strong>1 字节</strong>的数据），而对方就在确认这个探测报文段时<strong>给出了现在的窗口值</strong>。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。<strong>若窗口不是零，则死锁的僵局就可以打破了</strong>。</p>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><h4 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h4><ol>
<li><p><strong>拥塞</strong>：在某段时间，若对网络中<strong>某资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为拥塞 congestion。简单的增加网络中的资源并不能解决拥塞问题。换句话说，就是<strong>网络中的数据量太大</strong>。</p>
</li>
<li><p><strong>拥塞控制</strong>：<strong>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</strong></p>
</li>
<li><p>拥塞控制与流量控制的区别：</p>
<ol>
<li><p>流量控制往往指<strong>点对点通信量</strong>的控制，是个端到端的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
</li>
<li><p>拥塞控制是一个<strong>全局性（整个网络）</strong>的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
</li>
<li><p>二者的共同点就是：目的都是<strong>降低数据发送速率。</strong>都是<strong>基于窗口</strong>的，<strong>接收窗口rwnd和拥塞窗口cwnd</strong>。</p>
</li>
</ol>
</li>
<li><p>下图横坐标为提供的负载（offered load），纵坐标为吞吐量（throughput），当网络的吞吐量反而随着提供的负载的增大而下降，就进入了<strong>拥塞状态</strong>，当到了一定程度，吞吐量下降到0，就是<strong>死锁（dead lock）</strong>。</p>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/yongsaikongzhi.png" alt=""></p>
<h4 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h4><ol>
<li><p>分为四种，<strong>慢开始，拥塞避免，快重传，快恢复</strong>。</p>
</li>
<li><p>TCP 采用<strong>基于窗口</strong>的方法进行拥塞控制。该方法属于闭环控制方法。</p>
</li>
<li><p>TCP发送方维持一个<strong>拥塞窗口 CWND CongestionWindow</strong>。拥塞窗口的大小取决于<strong>网络的拥塞程度</strong>，并且<strong>动态地</strong>在变化。发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：<strong>min（接收窗口，拥塞窗口）</strong>。</p>
</li>
<li><p>如何判断出现了拥塞：</p>
<ol>
<li><p><strong>重传定时器超时（整个网络出现了拥塞，需要重新慢开始）</strong></p>
</li>
<li><p><strong>收到三个相同（重复）的 ACK（某个字节序号的数据丢失，跟快重传机制有关，需要进行快开始）</strong></p>
</li>
</ol>
</li>
</ol>
<h4 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h4><h5 id="慢开始-slow−start"><a href="#慢开始-slow−start" class="headerlink" title="慢开始 slow−start"></a><strong>慢开始 slow−start</strong></h5><ol>
<li>算法的思路：<strong>由小到大逐渐增大拥塞窗口数值，每一个传输轮次对拥塞窗口进行==加倍==</strong>。</li>
<li>初始拥塞窗口 cwnd 设置：<ol>
<li>旧的规定：在刚刚开始发送报文段时，先把<strong>初始拥塞窗口cwnd</strong> 设置为 <strong>1 至 2 个</strong>发送方的最大报文段 <strong>SMSS</strong> Sender Maximum Segment Size的数值。</li>
<li>新的 RFC 5681 把初始拥塞窗口 cwnd 设置为<strong>不超过2至4个</strong>SMSS 的数值。</li>
</ol>
</li>
<li><strong>慢开始门限 ssthresh（状态变量）</strong>：防止拥塞窗口cwnd 增长过大引起网络拥塞。到达ssthresh就由<strong>慢开始算法变为拥塞控制算法</strong>（<strong>指数增加到线性增加</strong>）</li>
<li>拥塞窗口 cwnd 控制方法：在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口<strong>增加最多一个 SMSS</strong> 的数值。<strong>发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。 每经过一个传输轮次，拥塞窗口就加倍。拥塞窗口的大小指数增加。</strong></li>
<li>“传输轮次”更加强调：<strong>把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认</strong>。</li>
</ol>
<h5 id="拥塞避免-congestion-avoidance"><a href="#拥塞避免-congestion-avoidance" class="headerlink" title="拥塞避免 congestion avoidance"></a><strong>拥塞避免 congestion avoidance</strong></h5><ol>
<li>思路：让拥塞窗口 cwnd 缓慢地增大，即<strong>每经过一个传输轮次</strong>就把发送方的拥塞窗口 cwnd <strong>加 1</strong>，而不是加倍，使拥塞窗口 cwnd 按<strong>线性规律</strong>缓慢增长。</li>
<li><p>每当在慢开始阶段或者拥塞避免阶段出现了网络拥塞（确认超时）：</p>
<ol>
<li>ssthresh = max（cwnd/ 2，2）</li>
<li>cwnd = 1</li>
<li>执行慢开始算法</li>
</ol>
</li>
<li>ssthresh一开始是默认的，后面根据拥塞发生时的窗口大小动态改变<strong>（乘以1/2）</strong></li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/yongsaikongzhiTCP.png" alt=""></p>
<h4 id="快重传-fast-retransmit："><a href="#快重传-fast-retransmit：" class="headerlink" title="快重传 fast retransmit："></a><strong>快重传 fast retransmit</strong>：</h4><ol>
<li><strong>快重传</strong>：算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了失序的报文段也要立<strong>即发出对已收到的最后一个报文段的重复确认</strong>。（原先的接收方如果收到了失序的报文段是仅仅收下而不反馈任何信息的。这样会导致无法区分<strong>到底是个别报文段因某些因素丢失了还是整个网络出现了拥塞</strong>。这样会使发送方超时，从而<strong>错误地开启慢开始算法</strong>）</li>
<li>发送方只要<strong>一连收到三个重复确认</strong>，就知道接收方确实没有收到报文段，因而应当<strong>立即进行重传（即“快重传”）</strong>，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</li>
</ol>
<h4 id="快恢复-fast-recovery"><a href="#快恢复-fast-recovery" class="headerlink" title="快恢复 fast recovery"></a>快恢复 fast recovery</h4><ol>
<li><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，而是报文产生了丢失，问题没有那么严重。因此现在不执行慢开始算法，而是执行<strong>快恢复算法 FR Fast Recovery</strong>算法</p>
<p>：</p>
<ol>
<li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li>
</ol>
</li>
<li><p><strong>新拥塞窗口 cwnd = 慢开始门限 ssthresh</strong> ；（超时导致的重新慢开始，cnwd=1）</p>
<ol>
<li>开始执行拥塞避免算法，使拥塞窗口缓慢地<strong>线性增大</strong>。</li>
</ol>
</li>
<li><p>又称AIMD 算法，AI为加法增大，MD为multiplicative decrease乘法减小：</p>
<ol>
<li>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“<strong>加法增大</strong>”。</li>
</ol>
</li>
<li>当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的<strong>一半</strong>，并大大减小拥塞窗口的数值。这常称为“<strong>乘法减小</strong>”。</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/TCPReno.png" alt="拥塞控制"></p>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/stationTCP.png" alt="TCP拥塞控制"></p>
<ol>
<li>TCP连接中，发送方发送窗口的最大值<strong>等于拥塞窗口cwnd（拥塞控制）和接收窗口rwnd（流量控制）二者的最小值。</strong></li>
</ol>
<h4 id="主动队列管理AQM（主动丢弃分组）"><a href="#主动队列管理AQM（主动丢弃分组）" class="headerlink" title="主动队列管理AQM（主动丢弃分组）"></a>主动队列管理AQM（主动丢弃分组）</h4><ol>
<li><p>网络层的<strong>路由器分组丢弃策略</strong>对TCP拥塞控制影响很大。</p>
</li>
<li><p><strong>尾部丢弃策略</strong>：当发生拥塞后，路由器将队列尾部的分组<strong>全部</strong>丢弃。这可能导致<strong>全局同步</strong>。</p>
</li>
<li><p><strong>全局同步</strong>：若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到<strong>慢开始</strong>状态。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p>
</li>
<li><p>AQM：在队列长度达到某个<strong>值得警惕的数值</strong>时（即当网络拥塞有了某些拥塞征兆时），就<strong>主动丢弃</strong>到达的分组。</p>
</li>
<li><p>AQM的实现方法：<strong>RED随机早期检测</strong>。</p>
<ol>
<li>使路由器的队列维持两个参数：<strong>队列长度最小门限 THmin 和最大门限 Thmax</strong> 。</li>
<li>RED 对每一个到达的分组都先计算当前路由器队列的<strong>平均队列长度 LAV</strong> 。</li>
<li>若平均队列长度小于<strong>最小门限 THmin</strong>，则将新到达的分组放入队列进行<strong>排队</strong>。</li>
<li>若平均队列长度超过<strong>最大门限 THmax</strong>，则将新到达的分组<strong>丢弃</strong>。</li>
<li>若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照<strong>某一概率 p</strong> 将新到达的分组丢弃。</li>
</ol>
</li>
</ol>
<h4 id="TCP运输连接"><a href="#TCP运输连接" class="headerlink" title="TCP运输连接"></a>TCP运输连接</h4><ol>
<li><p>TCP 是<strong>面向连接</strong>的协议，需要<strong>在客户端和服务器之间</strong>建立连接。运输连接有三个阶段：<strong>连接建立、数据传送、连接释放</strong></p>
</li>
<li><p>运输连接的管理就是使运输连接的<strong>建立和释放</strong>都能正常地进行。</p>
</li>
</ol>
<h5 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h5><p>TCP建立连接的过程叫握手</p>
<ol>
<li><p><strong>三报文握手</strong>（三次握手）</p>
<ol>
<li><p>本例中，A为TCP客户程序，是<strong>主动打开连接</strong>，B为TCP服务器程序，是<strong>被动打开连接</strong>。B的TCP服务器进程先创建<strong>传输控制块TCP</strong>，A的TCP客户进程也是首先创建<strong>传输控制块TCB</strong>。</p>
</li>
<li><p>A 的 TCP 向 B 发出<strong>连接请求报文段</strong>，其首部中的同步位 <strong>SYN = 1（表明是一个连接请求报文段）</strong>，并选择序号 <strong>seq = x</strong>，表明传送数据时的<strong>第一个数据字节的序号是 x</strong>。TCP客户进程进入SYN-SENT（同步已发送）状态。</p>
</li>
<li><p>B 的 TCP 收到连接请求报文段后，如同意，则<strong>发回确认</strong>。B 在确认报文段中应使 <strong>SYN = 1（表明是一个连接接受报文段）</strong>，使 <strong>ACK = 1（表示当前为确认请求报文段）</strong>，其确认号<strong>ack = x + 1</strong>，自己选择的序号 <strong>seq = y</strong>。TCP服务器进程进入SYN-RCVD（同步收到）状态。</p>
</li>
<li><p>A 收到此报文段后向 B <strong>给出确认</strong>，其 <strong>ACK = 1</strong>，确认号 <strong>ack = y + 1</strong>。A 的 TCP <strong>通知上层应用进程</strong>，连接已经建立。B 的 TCP 收到主机 A 的确认后，也<strong>通知其上层应用进程</strong>：TCP 连接已经建立。此时都进入ESTABLISHED状态。此时ACK报文段可以携带数据，但如果不携带则<strong>不消耗序号</strong>。</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/sanciwoshou.png" alt="三次握手"></p>
<ol>
<li><p>为什么要三次握手：</p>
<ol>
<li>第一次握手是为了<strong>请求建立TCP连接</strong>，显然是必须的。</li>
<li>第二次握手是为了<strong>让客户端知道连接已经成功建立</strong>。如果没有第二次握手，假如连接建立失败，此时客户端<strong>不知情</strong>，会继续发送数据，导致出错。</li>
<li>第三次握手是<strong>防止失效了的连接建立请求再次到达服务端，导致服务端试图再次建立连接，从而产生错误</strong>。所以，B建立连接时需要再次向A进行确认。</li>
</ol>
</li>
</ol>
<h4 id="TCP释放连接"><a href="#TCP释放连接" class="headerlink" title="TCP释放连接"></a>TCP释放连接</h4><ol>
<li><p>数据传输结束后，通信的<strong>双方</strong>都可释放连接。现在 A 的应用进程先向其 TCP 发出<strong>连接释放报文段</strong>，并<strong>停止再发送数据</strong>，主动关闭 TCP 连接。A 把连接释放报文段首部的 <strong>FIN = 1</strong>，其序号<strong>seq = u</strong>，u等于前面已传送过的数据的最后一个字节的序号加一，等待 B 的确认。<strong>TCP的FIN报文段即使不携带数据，也会消耗一个序号</strong>。</p>
</li>
<li><p>B 发出<strong>确认</strong>，<strong>ACK = 1</strong>，确认号 <strong>ack = u + 1</strong>，而这个报文段自己的序号 <strong>seq = v</strong>，同u为B发送的最后一个字节加一。TCP 服务器进程通知高层应用进程。<strong>从 A 到 B 这个方向</strong>的连接就释放了，TCP 连接处于<strong>半关闭状态</strong>。B 若发送数据，A 仍要接收。</p>
</li>
<li><p>此时，从B到A这个方向的连接尚未释放，<strong>B可以发送剩余的数据给A</strong>（因为是A发起的关闭连接，所以A到B的数据必然已经传输完，但B到A的不一定）。等B发送完剩余的数据，向A发送<strong>连接释放报文段</strong>，并<strong>停止再发送</strong>。该报文段首部的 <strong>FIN = 1，ACK = 1</strong>（<strong>表示是响应的释放连接，而不是主动释放</strong>），确认号 <strong>ack = u + 1</strong>。</p>
</li>
<li><p>A 收到连接释放报文段后，必须发出<strong>确认</strong>。 在确认报文段中 <strong>ACK = 1</strong>，确认号 <strong>ack = w + 1</strong>，自己的序号 <strong>seq = u + 1</strong>。 此时，A在等待<strong>2MSL（最长报文寿命，RFC793中设为2min）</strong>后，<strong>彻底释放TCP连接</strong>。</p>
</li>
</ol>
<p><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/siciwoshou.png" alt="四次挥手"></p>
<p>为什么A要等待2MSL才能宣布TCP彻底释放：</p>
<ol>
<li>为了保证 <strong>A 发送的最后一个 ACK 报文段能够到达 B。</strong>即A等到2MSL后，当出现A发送的确认报文段丢失时，可以收到B超时重传报文段，从而<strong>再次确认</strong>，使连接正常释放。</li>
<li><strong>防止 “已失效的连接请求报文段”出现在本连接中</strong>。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以<strong>使本连接持续的时间内所产生的所有报文段，都从网络中消失。</strong>这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Jerry Jiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0/">http://example.com/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Jerryの魔法小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="计网第三章"><img class="cover" src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计网第三章</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/28/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%85%AD%E7%AB%A0/" title="计网第三章"><img class="cover" src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计网第三章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jerry Jiang</div><div class="author-info__description">赞美太阳！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/etherea1ity"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/etherea1ity" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:jsj31415926@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的小屋！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">第五章 运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.</span> <span class="toc-text">重要内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">核心知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">运输层协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">进程之间的通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">运输层的两个主要协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E7%AB%AF%E5%8F%A3%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%AB%AF%E5%8F%A3%EF%BC%89%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%88%86%E7%94%A8%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">运输层的端口（软件端口）：解决分用问题。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP"><span class="toc-number">1.2.2.</span> <span class="toc-text">用户数据报协议UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">UDP概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">UDP的首部格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP"><span class="toc-number">1.2.3.</span> <span class="toc-text">传输控制协议TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">TCP最主要的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">TCP的连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">可靠传输的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%EF%BC%88%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84ARQ%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%89"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">停止等待协议（最基本的ARQ协议，滑动窗口协议的基础）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">TCP报文段的首部格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.6.</span> <span class="toc-text">滑动窗口协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%9A%84ARQ%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">连续的ARQ协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">以字节为单位的滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4RTO"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">超时重传时间RTO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.7.</span> <span class="toc-text">TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">利用滑动窗口实现流量控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.8.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">拥塞控制的一般原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">TCP 的拥塞控制方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">TCP拥塞控制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B-slow%E2%88%92start"><span class="toc-number">1.2.8.3.1.</span> <span class="toc-text">慢开始 slow−start</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-congestion-avoidance"><span class="toc-number">1.2.8.3.2.</span> <span class="toc-text">拥塞避免 congestion avoidance</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0-fast-retransmit%EF%BC%9A"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">快重传 fast retransmit：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%81%A2%E5%A4%8D-fast-recovery"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">快恢复 fast recovery</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM%EF%BC%88%E4%B8%BB%E5%8A%A8%E4%B8%A2%E5%BC%83%E5%88%86%E7%BB%84%EF%BC%89"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">主动队列管理AQM（主动丢弃分组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">TCP运输连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.8.7.1.</span> <span class="toc-text">TCP建立连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.8.8.</span> <span class="toc-text">TCP释放连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">课后习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统第一章"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统第一章"/></a><div class="content"><a class="title" href="/2023/11/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统第一章">操作系统第一章</a><time datetime="2023-11-10T06:07:21.000Z" title="发表于 2023-11-10 14:07:21">2023-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="计网第四章"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计网第四章"/></a><div class="content"><a class="title" href="/2023/11/09/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="计网第四章">计网第四章</a><time datetime="2023-11-09T12:05:34.000Z" title="发表于 2023-11-09 20:05:34">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/09/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B9%9D%E7%AB%A0/" title="计网第九章"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/mountains-7750722_1920.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计网第九章"/></a><div class="content"><a class="title" href="/2023/11/09/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B9%9D%E7%AB%A0/" title="计网第九章">计网第九章</a><time datetime="2023-11-09T06:00:38.000Z" title="发表于 2023-11-09 14:00:38">2023-11-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/30/commonlit/" title="commonlit competition review"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/commonlit.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="commonlit competition review"/></a><div class="content"><a class="title" href="/2023/10/30/commonlit/" title="commonlit competition review">commonlit competition review</a><time datetime="2023-10-30T13:53:55.000Z" title="发表于 2023-10-30 21:53:55">2023-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="第一章绪论"><img src="https://imageurlbed.oss-cn-shenzhen.aliyuncs.com/img/DATABASECARTOON.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一章绪论"/></a><div class="content"><a class="title" href="/2023/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="第一章绪论">第一章绪论</a><time datetime="2023-10-30T10:33:39.000Z" title="发表于 2023-10-30 18:33:39">2023-10-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jerry Jiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>